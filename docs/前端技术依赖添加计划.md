# 前端技术依赖添加计划

## 概述

本文档详细说明在番茄时钟项目中添加前端技术依赖的具体步骤和验证方法。

## TODO LIST
- 注意： 每一步骤完成要让我手动验证。
- 每一步你需要不回测试组件，并提供测试步骤说明
☒ 分析当前项目状态 - Pinia 已实现，其他依赖待添加
☒ 拆分 App.vue 文件 - 创建独立的组件
☒ 添加 Lucide Vue 图标库依赖
☒ 添加 dayjs 日期时间处理依赖
☒ 添加 localforage 本地存储依赖
☒ 配置 Lucide Vue 图标库
☒ 创建 dayjs 时间处理工具函数
☒ 创建 localforage 存储服务
☒ Pinia store 集成到 localforage
☒ 更新组件使用 Lucide 图标
☒ 更新组件使用 dayjs 时间格式化
☒ 验证所有依赖集成正常工作
☒ 添加 Inter 字体依赖
☒ 配置全局字体样式
☒ 验证字体集成
☒ 安装 Inter 字体 npm 包
☒ 更新样式使用本地字体
☒ 移除 Google Fonts 依赖
☒ 验证本地字体集成
☐ 添加 Tailwind CSS 依赖
☐ 配置 Tailwind CSS
☐ 创建 Tailwind 配置文件
☐ 更新 CSS 文件引入 Tailwind
☐ 验证 Tailwind CSS 集成

## 依赖清单

### 核心依赖
- **Pinia** - 状态管理
- **Lucide Vue** - 图标库
- **dayjs** - 日期时间处理
- **localforage** - 本地存储
- **Tailwind CSS** - CSS 框架

## 1. Pinia 状态管理

### 添加步骤

#### 1.1 安装 Pinia
```bash
pnpm add pinia
```

#### 1.2 配置 Pinia
在 `src/main.ts` 中添加 Pinia 配置：

```typescript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
```

#### 1.3 创建状态管理文件
创建 `src/stores/timerStore.js`：

```javascript
import { defineStore } from 'pinia'

export const useTimerStore = defineStore('timer', {
  state: () => ({
    currentTime: 25 * 60, // 25分钟
    isRunning: false,
    mode: 'pomodoro', // pomodoro, shortBreak, longBreak
    settings: {
      pomodoroTime: 25,
      shortBreakTime: 5,
      longBreakTime: 15
    }
  }),
  actions: {
    startTimer() {
      this.isRunning = true
    },
    pauseTimer() {
      this.isRunning = false
    },
    resetTimer() {
      this.isRunning = false
      this.currentTime = this.settings.pomodoroTime * 60
    }
  }
})
```

#### 1.4 在组件中使用
在需要使用状态的组件中：

```vue
<script setup>
import { useTimerStore } from '@/stores/timerStore'

const timerStore = useTimerStore()
</script>

<template>
  <div>{{ timerStore.currentTime }}</div>
  <button @click="timerStore.startTimer">开始</button>
</template>
```

### 验证步骤

#### 1.5 基础验证
- 运行 `pnpm dev` 确保应用启动正常
- 检查控制台是否有错误信息
- 确认 Pinia DevTools 在浏览器开发者工具中可用

#### 1.6 功能验证
- 在组件中访问状态数据
- 测试状态修改功能
- 验证状态在不同组件间的同步

## 2. Lucide Vue 图标库

### 添加步骤

#### 2.1 安装 Lucide Vue
```bash
pnpm add lucide-vue-next
```

#### 2.2 全局注册（可选）
在 `src/main.ts` 中注册：

```typescript
import * as LucideIcons from 'lucide-vue-next'

// 全局注册所有图标
Object.entries(LucideIcons).forEach(([name, component]) => {
  app.component(name, component)
})
```

#### 2.3 按需导入使用
在组件中按需导入：

```vue
<script setup>
import { Play, Pause, RotateCcw } from 'lucide-vue-next'
</script>

<template>
  <button>
    <Play :size="24" :stroke-width="2" />
  </button>
</template>
```

### 验证步骤

#### 2.4 基础验证
- 运行 `pnpm dev` 确保应用启动正常
- 检查图标是否正确渲染
- 验证图标属性（大小、颜色等）是否生效

#### 2.5 功能验证
- 测试动态属性绑定
- 验证图标在不同主题下的显示
- 检查图标组件的性能表现

## 3. dayjs 日期时间处理

### 添加步骤

#### 3.1 安装 dayjs
```bash
pnpm add dayjs
```

#### 3.2 创建工具函数
创建 `src/utils/timeUtils.js`：

```javascript
import dayjs from 'dayjs'
import duration from 'dayjs/plugin/duration'

dayjs.extend(duration)

export function formatTime(seconds) {
  const duration = dayjs.duration(seconds, 'seconds')
  const minutes = duration.minutes()
  const secs = duration.seconds()
  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
}

export function getDuration(minutes) {
  return dayjs.duration(minutes, 'minutes').asSeconds()
}
```

#### 3.3 在组件中使用
```vue
<script setup>
import { formatTime } from '@/utils/timeUtils'
import { computed } from 'vue'

const props = defineProps({
  seconds: {
    type: Number,
    required: true
  }
})

const formattedTime = computed(() => formatTime(props.seconds))
</script>

<template>
  <div>{{ formattedTime }}</div>
</template>
```

### 验证步骤

#### 3.4 基础验证
- 运行 `pnpm dev` 确保应用启动正常
- 测试时间格式化功能
- 验证时间计算准确性

#### 3.5 功能验证
- 测试边界情况（0秒、负数等）
- 验证不同格式的输出
- 检查性能表现

## 4. localforage 本地存储

### 添加步骤

#### 4.1 安装 localforage
```bash
pnpm add localforage
```

#### 4.2 创建存储服务
创建 `src/services/storageService.js`：

```javascript
import localforage from 'localforage'

// 配置存储实例
const taskStore = localforage.createInstance({
  name: 'tomato-timer',
  storeName: 'tasks'
})

const settingsStore = localforage.createInstance({
  name: 'tomato-timer',
  storeName: 'settings'
})

export const storage = {
  // 任务相关
  async getTasks() {
    return await taskStore.getItem('tasks') || []
  },
  
  async saveTasks(tasks) {
    return await taskStore.setItem('tasks', tasks)
  },
  
  async addTask(task) {
    const tasks = await this.getTasks()
    tasks.push(task)
    return await this.saveTasks(tasks)
  },
  
  // 设置相关
  async getSettings() {
    return await settingsStore.getItem('settings') || {
      pomodoroTime: 25,
      shortBreakTime: 5,
      longBreakTime: 15
    }
  },
  
  async saveSettings(settings) {
    return await settingsStore.setItem('settings', settings)
  }
}
```

#### 4.3 在状态管理中集成
修改 `src/stores/timerStore.js`：

```javascript
import { defineStore } from 'pinia'
import { storage } from '@/services/storageService'

export const useTimerStore = defineStore('timer', {
  state: () => ({
    // ... 其他状态
    settings: {
      pomodoroTime: 25,
      shortBreakTime: 5,
      longBreakTime: 15
    }
  }),
  actions: {
    async loadSettings() {
      const settings = await storage.getSettings()
      this.settings = settings
    },
    
    async saveSettings() {
      await storage.saveSettings(this.settings)
    }
  }
})
```

### 验证步骤

#### 4.4 基础验证
- 运行 `pnpm dev` 确保应用启动正常
- 测试数据存储功能
- 验证数据持久化（刷新页面后数据依然存在）

#### 4.5 功能验证
- 测试数据读取和写入
- 验证错误处理（存储空间不足等）
- 检查数据同步性

## 5. Tailwind CSS CSS 框架

### 添加步骤

#### 5.1 安装 Tailwind CSS
**注意版本兼容性问题**：Tailwind CSS 4.x 版本与传统初始化命令不兼容，建议使用 3.x 版本。

```bash
pnpm add -D tailwindcss@^3.4.0 postcss autoprefixer
```

#### 5.2 初始化 Tailwind CSS
```bash
pnpm exec tailwindcss init -p
```

**⚠️ 版本兼容性问题解决**：

如果遇到 `'tailwindcss' 不是内部或外部命令` 错误：

**问题诊断**：
- Tailwind CSS 4.x 版本与 `tailwindcss init` 命令不兼容
- 需要使用 3.x 版本才能正常工作

**解决方案**：
```bash
# 1. 卸载错误版本
pnpm remove tailwindcss

# 2. 安装正确版本
pnpm add -D tailwindcss@^3.4.0

# 3. 重新初始化
pnpm exec tailwindcss init -p
```

#### 5.3 配置 Tailwind CSS
修改 `tailwind.config.js`：

```javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#fef2f2',
          100: '#fee2e2',
          200: '#fecaca',
          300: '#fca5a5',
          400: '#f87171',
          500: '#ef4444',
          600: '#dc2626',
          700: '#b91c1c',
          800: '#991b1b',
          900: '#7f1d1d',
        }
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
    },
  },
  plugins: [],
}
```

#### 5.4 更新 CSS 文件
修改 `src/style.css`：

**⚠️ CSS 顺序问题解决**：

**问题**：构建时出现 `@import must precede all other statements` 错误

**解决方案**：将 `@import` 语句移到所有其他语句之前

```css
/* 导入本地 Inter 字体 */
@import '@fontsource/inter/300.css';
@import '@fontsource/inter/400.css';
@import '@fontsource/inter/500.css';
@import '@fontsource/inter/600.css';
@import '@fontsource/inter/700.css';

/* Tailwind CSS */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 自定义基础样式 */
@layer base {
  html {
    font-family: Inter, system-ui, sans-serif;
  }
  
  body {
    @apply bg-gray-50 text-gray-900;
  }
}

/* 自定义组件样式 */
@layer components {
  .btn-primary {
    @apply bg-primary-600 hover:bg-primary-700 text-white font-medium py-2 px-4 rounded-lg transition-colors;
  }
  
  .btn-secondary {
    @apply bg-gray-200 hover:bg-gray-300 text-gray-800 font-medium py-2 px-4 rounded-lg transition-colors;
  }
  
  .timer-display {
    @apply text-6xl font-bold text-primary-600 tabular-nums;
  }
}
```

#### 5.5 配置 PostCSS
确保 `postcss.config.js` 包含：

```javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

#### 5.6 在组件中使用
在 Vue 组件中使用 Tailwind CSS：

```vue
<template>
  <div class="min-h-screen bg-gray-50 flex flex-col items-center justify-center">
    <div class="bg-white rounded-2xl shadow-lg p-8 max-w-md w-full">
      <h1 class="text-3xl font-bold text-center mb-8 text-gray-900">
        番茄时钟
      </h1>
      
      <div class="timer-display mb-8 text-center">
        {{ formattedTime }}
      </div>
      
      <div class="flex justify-center space-x-4">
        <button 
          @click="startTimer" 
          class="btn-primary flex items-center space-x-2"
        >
          <Play :size="20" />
          <span>开始</span>
        </button>
        
        <button 
          @click="pauseTimer" 
          class="btn-secondary flex items-center space-x-2"
        >
          <Pause :size="20" />
          <span>暂停</span>
        </button>
      </div>
    </div>
  </div>
</template>
```

### 验证步骤

#### 5.7 基础验证
- 运行 `pnpm dev` 确保应用启动正常
- 检查 Tailwind CSS 样式是否正确加载
- 验证自定义样式类是否生效

#### 5.8 功能验证
- 测试响应式设计（不同屏幕尺寸）
- 验证自定义颜色和字体
- 检查组件样式的复用性
- 确认构建后的样式正确性

#### 5.9 开发体验验证
- 测试 IDE 的 Tailwind CSS 智能提示
- 验证样式热更新
- 检查开发工具的样式检查

## 开发工作流程

### 每次依赖添加的流程

1. **计划阶段**
   - 确定要添加的依赖
   - 查看官方文档
   - 制定添加步骤

2. **实施阶段**
   - 安装依赖包
   - 配置相关文件
   - 编写示例代码

3. **自检阶段**
   - 检查语法错误
   - 验证基本功能
   - 确保代码质量

4. **验证阶段**
   - 用户执行 `pnpm dev`
   - 功能测试
   - 性能检查

### 质量检查清单

- [ ] 依赖版本兼容性
- [ ] TypeScript 类型定义
- [ ] 代码格式和规范
- [ ] 错误处理机制
- [ ] 性能影响评估
- [ ] 安全性考虑

### 常见问题处理

#### Tailwind CSS 版本兼容性问题
**问题**：运行 `pnpm exec tailwindcss init -p` 时提示 `'tailwindcss' 不是内部或外部命令`

**原因**：Tailwind CSS 4.x 版本与传统初始化命令不兼容

**解决方案**：
```bash
# 1. 检查当前版本
pnpm list tailwindcss

# 2. 如果是 4.x 版本，卸载并重新安装 3.x 版本
pnpm remove tailwindcss
pnpm add -D tailwindcss@^3.4.0

# 3. 重新初始化
pnpm exec tailwindcss init -p
```

#### CSS @import 顺序问题
**问题**：构建时出现 `@import must precede all other statements` 错误

**原因**：PostCSS 要求 `@import` 语句必须放在所有其他语句之前

**解决方案**：
```css
/* 正确顺序 */
@import 'path/to/font.css';
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 错误顺序 */
@tailwind base;
@import 'path/to/font.css';  /* 这会报错 */
```

#### 版本冲突
- 使用 `pnpm why <package>` 查看依赖关系
- 调整版本号解决冲突
- 使用 `pnpm update` 更新依赖

#### 性能问题
- 检查包大小影响
- 优化按需加载
- 使用代码分割

#### 类型错误
- 安装对应的类型定义包
- 添加必要的类型声明
- 配置 TypeScript 选项

## 总结

按照此计划逐步添加前端技术依赖，确保每个依赖都经过充分验证，保证项目的稳定性和可维护性。每个依赖的添加都应该遵循增量开发的原则，确保代码始终处于可用状态。